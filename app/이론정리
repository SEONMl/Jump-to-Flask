SSH - 네트워크 상의 다른 컴퓨터에 로그인하거나 원격 시스템의 명령을 수행하기 위한 프로토콜 (기본포트 22번)

SECRET_KEY - 플라스크가 어떤 값을 암호화할 때 사용하는 중요한 환경 변수다. 예를 들어 로그인 비밀번호 등은 이 SECRET_KEY를 사용해 암호화된다.

WSGI(위스키) - 파이썬 프로그램을 호출하여 동적 페이지 요청을 처리하는 것
ex) Gunicorn, uwsgi 사용
=> flask run : 명령으로 동작한 서버는 플라스크의 내장 서버, 기능 단순, 대량 요청이나 동시 요청 효율적 처리 못함
pip install gunicorn
gunicorn --bind 0:5000 'pybo:create_app()'
gunicorn --bind unix:/tmp/myproject.sock "pybo:create_app()"

유닉스 소켓 방식으로 Gunicorn 서버를 실행하면 단독으로 Gunicorn 서버에 접속하여 실행해 볼 수 없다.
유닉스 소켓 방식으로 실행한 Gunicorn 서버는 Nginx와 같은 웹 서버에서 유닉스 소켓으로 WSGI 서버에 접속하도록 설정해야 한다.

HTTPS = HTTP + SSL(Secured Socket Layer, 보안기능, 443 포트)
SSL 인증서를 발급받아 Nginx에 적용하면 HTTPS 프로토콜 서비스 가능
Let's Encrypt 무료 SSL 인증서 발급 서비스
sudo apt install certbot
sudo apt install python3-certbot-nginx
sudo certbot certonly --nginx



python
class Mul:
    def __init__(self, m):
        self.m = m

    def __call__(self, n):
         return self.m * n
>>> mul3 = Mul(3)
>>> print(mul3(10)) # 30 출력

----------------------------------
데코레이터 -> 함수도 하나의 객체로 취급되기 때문

def mul_of(m):
    def mul(n):
        return m * n
    return mul


if __name__ == "__main__":
    mul3 = mul_of(3)
    mul5 = mul_of(5)

    print(mul3(10))  # 30 출력
    print(mul5(10))  # 50 출력

------------------------------------------------
import time


def decorate(original_func):
    @functools.wraps(original_func) # 함수의 여러 속성을 보호하면서 데코레이트 함수를 만듦, 반드시 사용
    def wrapper(*args, **kwargs):
        start = time.time()
        original_func(*args, **kwargs)
        end = time.time()
        print("함수 수행시간: %f 초" % (end - start))
    return wrapper


@decorate
def myfunc():
    """ 데코레이터 확인 함수 """
    print("함수가 실행됩니다.")

# decorated_myfunc = decorate(myfunc)  # 데코레이터 어노테이션으로 인해 더이상 필요하지 않다.
# decorated_myfunc()
myfunc()

# 함수가 실행됩니다.
# 함수 수행시간: 0.000029 초

데코레이터 함수는 기존 함수의 입력인수에 상관없이 동작하도록 만들어야 한다.
왜냐하면 데코레이터는 기존함수가 어떤 입력인수를 취할지 알 수 없기 때문이다.
따라서 이렇게 전달받아야 하는 기존 함수의 입력인수를 알 수 없는 경우에는 *args와 **kwargs 기법을 이용하여 해결해야 한다.